name: Issue Comment Bot

on:
  issue_comment:
    types: [created]
  push:
    branches:
      - "**"

permissions:
  contents: read

jobs:
  dispatch-to-master:
    if: ${{ github.event_name == 'issue_comment' && github.event.issue.pull_request == null }}
    runs-on: ubuntu-latest
    steps:
      - name: Send repository_dispatch to master repo
        uses: actions/github-script@v7
        env:
          MASTER_OWNER: ${{ vars.MASTER_OWNER }}
          MASTER_REPO: ${{ vars.MASTER_REPO }}
        with:
          github-token: ${{ secrets.ORG_BOT_PAT }}
          script: |
            const parseTarget = (masterOwnerEnv, masterRepoEnv) => {
              const defaultOwner = 'PKO001Classroom';
              const defaultRepo = 'EDUAI2026AgentMaster001';
              const rawOwner = (masterOwnerEnv || '').trim();
              const rawRepo = (masterRepoEnv || '').trim();

              if (/^https?:\/\//i.test(rawRepo)) {
                try {
                  const parsed = new URL(rawRepo);
                  const parts = parsed.pathname.split('/').filter(Boolean);
                  if (parts.length >= 2) {
                    return {
                      owner: parts[0].trim() || defaultOwner,
                      repo: parts[1].trim() || defaultRepo,
                    };
                  }
                } catch (error) {
                }
              }

              if (rawRepo.includes('/')) {
                const parts = rawRepo.split('/').map((item) => item.trim()).filter(Boolean);
                if (parts.length >= 2) {
                  return {
                    owner: parts[0] || defaultOwner,
                    repo: parts[1] || defaultRepo,
                  };
                }
              }

              return {
                owner: rawOwner || defaultOwner,
                repo: rawRepo || defaultRepo,
              };
            };

            const { owner, repo } = parseTarget(process.env.MASTER_OWNER, process.env.MASTER_REPO);

            try {
              await github.request('GET /repos/{owner}/{repo}', { owner, repo });
            } catch (error) {
              const status = error?.status || 'unknown';
              throw new Error(
                `Dispatch target ${owner}/${repo} is not accessible (status: ${status}). ` +
                'Check MASTER_OWNER/MASTER_REPO values and ensure ORG_BOT_PAT has access to the master repo.'
              );
            }

            const payload = {
              _dispatch_event: 'issue_comment_event',
              action: context.payload.action,
              repository: {
                owner: { login: context.repo.owner },
                name: context.repo.repo
              },
              issue: {
                number: context.payload.issue?.number,
                pull_request: context.payload.issue?.pull_request || null
              },
              comment: {
                body: context.payload.comment?.body || '',
                html_url: context.payload.comment?.html_url || '',
                user: {
                  login: context.payload.comment?.user?.login || '',
                  type: context.payload.comment?.user?.type || ''
                }
              }
            };

            await github.request('POST /repos/{owner}/{repo}/dispatches', {
              owner,
              repo,
              event_type: 'issue_comment_event',
              client_payload: payload,
            });

  dispatch-push-to-master:
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    steps:
      - name: Send push repository_dispatch to master repo
        uses: actions/github-script@v7
        env:
          MASTER_OWNER: ${{ vars.MASTER_OWNER }}
          MASTER_REPO: ${{ vars.MASTER_REPO }}
        with:
          github-token: ${{ secrets.ORG_BOT_PAT }}
          script: |
            const parseTarget = (masterOwnerEnv, masterRepoEnv) => {
              const defaultOwner = 'PKO001Classroom';
              const defaultRepo = 'EDUAI2026AgentMaster001';
              const rawOwner = (masterOwnerEnv || '').trim();
              const rawRepo = (masterRepoEnv || '').trim();

              if (/^https?:\/\//i.test(rawRepo)) {
                try {
                  const parsed = new URL(rawRepo);
                  const parts = parsed.pathname.split('/').filter(Boolean);
                  if (parts.length >= 2) {
                    return {
                      owner: parts[0].trim() || defaultOwner,
                      repo: parts[1].trim() || defaultRepo,
                    };
                  }
                } catch (error) {
                }
              }

              if (rawRepo.includes('/')) {
                const parts = rawRepo.split('/').map((item) => item.trim()).filter(Boolean);
                if (parts.length >= 2) {
                  return {
                    owner: parts[0] || defaultOwner,
                    repo: parts[1] || defaultRepo,
                  };
                }
              }

              return {
                owner: rawOwner || defaultOwner,
                repo: rawRepo || defaultRepo,
              };
            };

            const { owner, repo } = parseTarget(process.env.MASTER_OWNER, process.env.MASTER_REPO);

            try {
              await github.request('GET /repos/{owner}/{repo}', { owner, repo });
            } catch (error) {
              const status = error?.status || 'unknown';
              throw new Error(
                `Dispatch target ${owner}/${repo} is not accessible (status: ${status}). ` +
                'Check MASTER_OWNER/MASTER_REPO values and ensure ORG_BOT_PAT has access to the master repo.'
              );
            }

            const payload = {
              _dispatch_event: 'repo_push_event',
              repository: {
                owner: { login: context.repo.owner },
                name: context.repo.repo
              },
              ref: context.payload.ref || '',
              before: context.payload.before || '',
              after: context.payload.after || '',
              compare: context.payload.compare || '',
              pusher: {
                name: context.payload.pusher?.name || ''
              },
              head_commit: context.payload.head_commit || {},
              commits: context.payload.commits || []
            };

            await github.request('POST /repos/{owner}/{repo}/dispatches', {
              owner,
              repo,
              event_type: 'repo_push_event',
              client_payload: payload,
            });
